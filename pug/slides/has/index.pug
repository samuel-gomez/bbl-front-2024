
-const { data: hasData } = require('./pug/slides/has/data.js');
+Section({name :'pseudo-element-has'})
	+Section({ name :'pseudo-element-has' })
		h1 Pseudo-element :has()
		p Le pseudo-élément :has() est une fonction CSS qui permet de sélectionner un élément qui contient un autre élément qui correspond à un sélecteur donné.
		pre                  
			+Code({ content : hasData[0].code, langage: 'css' })

	+Section({ name :'cas-basique' })
		h1 Cas basique
		p On va donc pouvoir sélectionner un élément parent en fonction de la présence d'un élément enfant.
		pre                  
			+Code({ content : hasData[1].code, langage: 'css',  dataLineNumbers: "4" })

	+Section({ name :'cas-layout' })
		h1 Custom layout
		p Si on peut déjà faire des choses intéressantes avec le cas basique, on peut aller plus loin en utilisant le pseudo-élément :has() pour créer des layouts personnalisés.
		pre                  
			+Code({ content : hasData[2].code, langage: 'css' }) 

	+Section({ name :'ET-logique' })
		h1 ET logique
		p Il est possible de chainer l'utilisation du pseudo-élément :has() afin d'avoir un ciblage plus précis.
		span.file Ici, on cible une carte qui possède une image ET un titre.
		pre                  
			+Code({ content : hasData[3].code, langage: 'css' })
  
	+Section({ name :'ET-OU-logique' })
		h1 ET/OU logique
		p Si on souhaite un ciblage plus souple, on peut fournir une liste de sélecteurs à la fonction :has().
		span.file Ici, on cible une carte qui possède soit une image, soit un titre. ou les deux.
		pre                  
			+Code({ content : hasData[4].code, langage: 'css' })

	+Section({ name :'ET-OU-logique-demo' })
		h1 Démo : ET/OU logique
		iframe(style="width: 100%;color: white; font-weight: bold;min-height: 65svh;" scrolling="no" title="has with combinator ~" src="https://codepen.io/gsam59/embed/RwOeWNr?default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true")
	
	+Section({ name :'selection-globale' })
		h1 Sélection globale
		p Pour finir dans les cas classiques du :has(), on peut utiliser la fonction pour sélectionner un élément parent en fonction de la présence d'un élément lointain enfant.
		span.file Dans l'exemple ci-dessous, on cherche à cibler le footer si quelque part dans le DOM ma checkbox est cochée.
		pre                  
			+Code({ content : hasData[5].code, langage: 'css' })

	+Section({ name :'selection-globale-demo' })
		h1 Démo : Sélection globale
		iframe(style="width: 100%;color: white; font-weight: bold;min-height: 65svh;" scrolling="no" title="has with combinator ~" src="https://codepen.io/gsam59/embed/RwOeWNr?default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true")
	
	+Section({ name :'elements-adjacents-direct' })
		h1 Eléments adjacents direct
		span.file Avec les combinateurs "+", on peut cibler un élément en fonction de la présence d'un élément précédent.		
		div(class=`${prefix}-cards-flex`) 
			+CardCode({ title: 'Combinateur "+"'})
				span.file on cible les paragraphes immédiatement précédés d'un h2.
				pre                     
					+Code({ content : hasData[6].code   })
			+CardCode({ title: 'has() et combinateur "+"'})
				span.file on cible les h2 immédiatement suivis d'un paragraphe.
				pre
					+Code({ content : hasData[7].code  })

	+Section({ name :'elements-adjacents-direct-demo' })
		h1 Démo : Eléments adjacents direct
		iframe(style="width: 100%;color: white; font-weight: bold;min-height: 80svh;" scrolling="no" title="has with combinator +" src="https://codepen.io/gsam59/embed/ZEZMdzj?default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true")
	
	+Section({ name :'elements-adjacents-indirect' })
		h1 Eléments adjacents indirect
		span.file Avec les combinateurs "~", on peut cibler un élément en fonction de la présence d'un élément précédent direct ou indirect.
		div(class=`${prefix}-cards-flex`) 
			+CardCode({ title: 'Combinateur "~"'})
				span.file on cible les paragraphes précédés d'un h2 direct ou indirect
				pre
					+Code({ content : hasData[8].code  })
			+CardCode({ title: 'has() et combinateur "~"'})
				span.file on cible les h2 suivis d'un paragraphe direct ou indirect.
				pre
					+Code({ content : hasData[9].code  })
	
	+Section({ name :'elements-adjacents-indirect-demo' })
		h1 Démo : Eléments adjacents indirect
		iframe(style="width: 100%;color: white; font-weight: bold;min-height: 60svh;" scrolling="no" title="has with combinator ~" src="https://codepen.io/gsam59/embed/wvZaOQN?default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true")
	
	+Section({ name :'cibler-un-scope' })
		h1 Cibler un intervalle
		p On peut également cibler un intervalle d'éléments adjacents
		span.file Dans l'exemple ci-dessous, on cherche à cibler le footer si quelque part dans le DOM ma checkbox est cochée.
		pre                  
			+Code({ content : hasData[10].code, langage: 'css' }) 
	
	+Section({ name :'cibler-un-scope-demo' })
		h1 Démo : Cibler un intervalle
		iframe(style="width: 100%;color: white; font-weight: bold;min-height: 60svh;" scrolling="no" title="has and ~ : from to " src="https://codepen.io/gsam59/embed/bGJxyoe?default-tab=css%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true")
	
	+Section({ name :'ciblage-par-quantite' })
		h1 Ciblage par quantité
		p On peut appliquer un style en fonction de la quantité d'éléments ciblés.
		a(href="https://developer.mozilla.org/fr/docs/Web/CSS/:has") Voir la documentation
		span.file Dans l'exemple ci-dessous, on cible les listes qui possèdent au moins 5 éléments.
		pre                  
			+Code({ content : hasData[11].code, langage: 'css' }) 

	+Section({ name :'ciblage-par-quantite-demo' })
		iframe(style="width: 100%;color: white; font-weight: bold;min-height: 60svh;" scrolling="no" title="has with combinator ~" src="https://codepen.io/gsam59/embed/PogpPVr?default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true")
	
	+Section({ name :'ciblage-par-attribut' })
		h1 Ciblage par attribut
		p On peut appliquer un style en fonction de la valeur d'un attribut.
		span.file On peut tirer partie de la puissance du sélecteur d'attribut et ses "expressions régulières".
		pre                  
			+Code({ content : hasData[12].code, langage: 'css' })
	
	+Section({ name :'ciblage-par-attribut-demo' })
		iframe(style="width: 100%;color: white; font-weight: bold;min-height: 60svh;" scrolling="no" title="has with combinator ~" src="https://codepen.io/gsam59/embed/MWRpBgN?default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true")
	